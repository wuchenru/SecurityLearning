
# Vulnerability: Heap Overflow and vtable Pointer Modification

## Introduction

Not only stack buffer overflow is a dangerous vulnerability, but heap-based buffer overflows can also pose severe security risks. This document explores how heap overflow can modify a vtable pointer, leading to malicious control flow.

---

## Class Example: Memory Layout and vtable

```cpp
class Foo {
public:
    int i, j, k; // Data members

    // Virtual functions
    virtual void bar() {
        cout << "Foo::bar() called!" << endl;
    }

    virtual void baz() {
        cout << "Foo::baz() called!" << endl;
    }

    // Destructor (for polymorphic behavior)
    virtual ~Foo() {
        cout << "Foo destructor called!" << endl;
    }
};
```

### Memory Diagram Explanation

When an object of a class with virtual functions is created, the compiler sets up the **vtable** (virtual function table) and links the object’s vtable pointer to it.

### Memory Layout of a C++ Object (with vtable pointer)

Victim object (`0x601030`):
```
+-------------------+
| vtable ptr         | ---> points to vtable
+-------------------+ 
| int i              | --- Instance variable 1
+-------------------+
| int j              | --- Instance variable 2
+-------------------+
| int k              | --- Instance variable 3
+-------------------+
```

### vtable Layout

The vtable is a static table where each entry corresponds to a virtual function.

```
vtable (points to by Victim's vtable pointer):
+----------------------------+
| ptr to Foo::bar()           | ---> points to Foo::bar() function
+----------------------------+
| ptr to Foo::baz()           | ---> points to Foo::baz() function
+----------------------------+
| ...                        |
+----------------------------+
```

---

## Example of Memory Flow

When a method like `bar()` or `baz()` is called on the object, the corresponding function is looked up in the **vtable**:

1. The program looks up the **vtable pointer** in the Victim object.
2. The **vtable pointer** leads to the vtable.
3. The program then calls the function at the index for `bar()`, i.e., the address stored in the vtable.

### Example Call

Calling `victim->bar()`:

- Look up the **vtable pointer** in the Victim object.
- Dereference the **vtable pointer** to access the vtable.
- Call the function at the index corresponding to `bar()`.

---

## Heap Overflow and vtable Pointer Modification

### How Heap Overflow Can Modify the vtable Pointer

In a **heap overflow attack**, an attacker can overwrite the **vtable pointer** by writing beyond a buffer allocated on the heap. This changes the function that gets called when a virtual function is invoked.

Victim object (`0x601030`):
```
+-------------------+
| vtable ptr         | ---> attacker modifies this to point to malicious code
+-------------------+
| int i              |  
+-------------------+
| int j              |  
+-------------------+
| int k              |  
+-------------------+
```

### Malicious vtable Example

```
Malicious vtable (attacker's crafted table):
+----------------------------+
| ptr to Malicious::func()    | ---> points to attacker-controlled function
+----------------------------+
| ptr to Malicious::func()    | ---> same malicious function or another
+----------------------------+
| ...                        |
+----------------------------+
```

By manipulating the **vtable pointer**, the attacker can change which function is executed, effectively hijacking the program’s control flow.

---

## Summary

Heap overflow attacks that overwrite vtable pointers are highly dangerous because they allow attackers to:

- Execute arbitrary code by redirecting function calls to attacker-controlled code.
- Exploit memory safety violations to bypass security mechanisms.

**Key Takeaway**: Proper memory management and bounds checking are essential to mitigate heap overflow vulnerabilities.

---
